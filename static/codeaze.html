<!DOCTYPE html>
<html>
    <head>
        <!--<script src=https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js></script>-->
        <script src=js/jQuery.1.7.2.min.js></script>
        <!--<script src=http://github.com/cowboy/jquery-resize/raw/v1.1/jquery.ba-resize.min.js></script>-->
        <script src=js/jquery.ba-resize.min.js></script>
        <script src=js/wUI.js></script>
        <script>
            window.KateSyntax = {base: 'js/syntax', debugTime: true, debugTrace: false};
            (function() {
                var script = document.createElement('script');
                script.src = KateSyntax.base+'/KateSyntax.js';
                document.head.appendChild(script);
            })();
        </script>
        <script src=js/wUI.editor.js></script>
        <link href=less/wUI.less rel=stylesheet/less type=text/x-less>
        <script src=js/less-1.3.0.min.js></script>
        <style>
            html, body {
                width: 100%;
                height: 100%;
            }
            body {
                margin: 0;
                font-size: 85%;
                font-family: 'Open Sans', Arial, sans-serif;
            }
            .input, .output {
                display: block;
                width: 96%;
                height: 48%;
                width: -moz-calc(100% - 2px);
                height: -moz-calc(50% - 2px);
                width: -webkit-calc(100% - 2px);
                height: -webkit-calc(50% - 2px);
                width: calc(100% - 2px);
                height: calc(50% - 2px);
                border: 1px solid #aaa;
                overflow: auto;
            }
            .error {
                background: #fee;
            }
        </style>
        <script src=http://traceur-compiler.googlecode.com/git/src/traceur.js></script>
        <script src=http://traceur-compiler.googlecode.com/git/src/bootstrap.js></script>
        <script type=text/traceur>
var codeaze;
{
    const RULE_DEFER = 0, RULE_STRING = 1, RULE_REGEX = 2, RULE_AND = 3, RULE_OR = 4, RULE_RANGE = 5, RULE_IS = 6, RULE_NOT = 7;
    class Rule {
        constructor(type, data, name) {
            this.type = type;
            this.name = name;
            if(type === RULE_DEFER || type === RULE_STRING || type === RULE_REGEX)
                this.data = data;
            else if(type === RULE_RANGE || type === RULE_IS || type === RULE_NOT)
                this.data = this.makeRule(data);
            //else if(data.length === 1 && (!name || (data[0] instanceof Rule) && (data[0].name || data[0].type === RULE_DEFER)))
            //    return this.makeRule(data[0], name);
            else {
                this.data = {};
                for(let i = 0; i < data.length; i++) {
                    this.addRule(data[i], '$'+i); // Numeric indexes can cause problems with ordering.
                }
            }
        }

        makeRule(data, name) {
            // rule
            if(data instanceof Rule) {
                if(!data.name && name)
                    data.name = name;
                return data;
            }
            // /rule/
            if(data instanceof RegExp)
                return new Rule(RULE_REGEX, RegExp('^'+data.source), name);
            // {name:rule}
            if(typeof data === 'object') {
                let keys = Object.keys(data);
                if(keys.length == 1)
                    return this.makeRule(data[keys[0]], name);
            }
            // 'rule'
            if(typeof data === 'string')
                return new Rule(RULE_STRING, data, name);
            console.log(data);
            throw new Error('Failed to make rule out of '+(typeof data));
        }

        addRule(data, i) {
            // Special case of objects, ensures they don't get passed to the next if.
            if(data instanceof Rule || data instanceof RegExp)
                return this.data[i] = this.makeRule(data);
            // {name:rule}
            if(typeof data === 'object') {
                let keys = Object.keys(data);
                if(keys.length == 1)
                    return this.data[keys[0]] = this.makeRule(data[keys[0]]);
            }
            return this.data[i] = this.makeRule(data);
        }

        // Helper function for RULE_RANGE, sets the separator between matches.
        sep(...params) {
            this.separator = new Rule(RULE_AND, params);
            return this;
        }

        filter(proc) {
            this.proc = proc;
            return this;
        }

        // Replaces any RULE_DEFER rules with the actual rules, returns the updated rule.
        fixDefer(rules) {
            // Recursion protection.
            if(this.fixedDefer)
                return this;
            this.fixedDefer = true;
            if(this.type === RULE_DEFER)
                return rules[this.data];
            if(this.type === RULE_RANGE || this.type === RULE_IS || this.type === RULE_NOT)
                this.data = this.data.fixDefer(rules);
            else if(this.type === RULE_AND || this.type === RULE_OR)
                for(let i in this.data)
                    this.data[i] = this.data[i].fixDefer(rules);
            return this;
        }

        parse(state) {
            let offset = state.offset;
            if(this.type === RULE_STRING)
                return state.text.slice(offset, offset+this.data.length) === this.data ? (state.offset += this.data.length, this.data) : false;
            if(this.type === RULE_REGEX) {
                let match = this.data.exec(state.text.slice(offset));
                return match ? (state.offset += match[0].length, match[0]) : false;
            }
            if(this.type === RULE_AND) {
                let matches = {};
                this.name && (matches._rule = this.name);
                for(let i in this.data)
                    if((matches[i] = this.data[i].parse(state)) === false)
                        return state.offset = offset, false; // The offset could have changed, needs resetting.
                    return this.proc ? this.proc(matches) : matches;
            }
            if(this.type === RULE_OR) {
                for(let i in this.data) {
                    let match = this.data[i].parse(state);
                    if(match !== false)
                        return this.proc ? this.proc(match) : match;
                }
                return state.offset = offset, false; // The offset could have changed, needs resetting.
            }
            if(this.type === RULE_RANGE) {
                if(this.min === 0 && this.max === 1) {
                    let match = this.data.parse(state);
                    return match === false ? null : match;
                }
                let matches = [];
                for(let i = 0; i < this.max; i++) {
                    let match = this.data.parse(state)
                    if(match === false)
                        break;
                    matches[i] = match;
                    if(this.separator) {
                        if((match = this.separator.parse(state)) === false)
                            break;
                        matches[i+.5] = match;
                    }
                }
                if(matches.length < this.min) // Less matches than the minimum of the range.
                    return state.offset = offset, false; // The offset could have changed, needs resetting.
                return matches;
            }
            if(this.type === RULE_IS) {
                let match = this.data.parse(state);
                if(match !== false)
                    state.offset = offset; // The offset could have changed, needs resetting.
                return match;
            }
            if(this.type === RULE_NOT) {
                let match = this.data.parse(state);
                if(match !== false)
                    return state.offset = offset, false; // The offset could have changed, needs resetting.
                return null;
            }
            throw new Error('Cannot parse type '+this.type);
        }
    };

    class Parser {
        constructor() {
            this.rules = {};
        }

        // `a,b,c,d`
        and(...rules) {
            return new Rule(RULE_AND, rules);
        }

        // `a|b|c|d`
        or(...rules) {
            return new Rule(RULE_OR, rules);
        }

        // `x{min,max}`
        range(r, ...rules) {
            let rule = new Rule(RULE_RANGE, this.and(...rules));
            rule.min = r[0] || 0, rule.max = r.length > 1 ? r[1] : rule.min;
            return rule;
        }

        // `x?`
        opt(...rules) {
            let rule = new Rule(RULE_RANGE, this.and(...rules));
            rule.min = 0, rule.max = 1;
            return rule;
        }

        // `x*`
        any(...rules) {
            let rule = new Rule(RULE_RANGE, this.and(...rules));
            rule.min = 0, rule.max = Infinity;
            return rule;
        }

        // `x+`
        more(...rules) {
            let rule = new Rule(RULE_RANGE, this.and(...rules));
            rule.min = 1, rule.max = Infinity;
            return rule;
        }

        // `&x`
        is(...rules) {
            return new Rule(RULE_IS, this.and(...rules));
        }

        // `!x`
        not(...rules) {
            return new Rule(RULE_NOT, this.and(...rules));
        }

        rule(name, ...params) {
            // Get a rule (or a RULE_DEFER for the rule's name).
            if(!params.length)
                return name in this.rules ? this.rules[name] : new Rule(RULE_DEFER, name);

            // Create a new rule.
            this.rules[name] = new Rule(RULE_AND, params, name);

            return this.rules[name];
        }

        build() {
            // Fix any defers.
            for(let i in this.rules)
                this.rules[i] = this.rules[i].fixDefer(this.rules);

            //TODO Compile all the rules to JS code.

            this.built = true;
        }

        parse(text) {
            if(!this.built)
                this.build();
            if(!this.topRule || !this.rules[this.topRule])
                throw new Error('Wrong top rule '+this.topRule)
            return this.rules[this.topRule].parse({text: text, offset: 0});
        }
    };

    const prettyPrint = (x, t)=>{
        const text = (x)=>document.createTextNode(x);
        const style = (c, x)=>{
            let elem = document.createElement('span');
            elem.className = 'ds'+c;
            elem.appendChild(text(x));
            return elem;
        }
        t = (t || '');
        let tNext = t+' ';//'    ';
        if(x === null)
            return [style('Keyword', 'null')];
        if(typeof x === 'number')
            return [style('DecVal', x.toString())];
        if(typeof x === 'string')
            return [style('String', '\''+x.replace(/([\\'])/g, '\\$1').replace(/\n/g, '\\n')+'\'')];
        if(Array.isArray(x)) {
            let s = [text('[')];
            for(let i = 0; i < x.length; i++) {
                s.push(text((i ? ',' : '') + '\n'+tNext), ...prettyPrint(x[i], tNext));
            }
            s.push(text('\n'+t+']'));
            return s;
        }
        if(typeof x === 'object') {
            let s = [], before = false;
            x._rule && s.push(style('Keyword', x._rule+' '));
            s.push(text('{'));
            for(let i in x) {
                if(i === '_rule')
                    continue;
                s.push(text((before ? ',' : (before = true, '')) + '\n'+tNext))
                s.push(style('DataType', i), text(': '), ...prettyPrint(x[i], tNext));
            }
            s.push(text('\n'+t+'}'));
            return s;
        }
        return [style('Error', 'unknown')];
    }

    codeaze = {Parser, prettyPrint};
}
let json = new codeaze.Parser, peg = new codeaze.Parser;
// JSON parser.
// This is the actual parser. Yes, it is really that small.
{
    let R = json.rule.bind(json), any = json.any.bind(json), or = json.or.bind(json), _ = R('space', /\s*/);

    R('number', /(?:[1-9][0-9]*|0)(.\d+)?/);
    R('string', '"',{value:/(?:[^\\"]|\\.)*/},'"');
    R('array', '[',_,{values:any(R('value')).sep(_,',',_)},_,']');
    R('object', '{',_,{values:any({name:R('string')},_,':',_,{value:R('value')}).sep(_,',',_)},_,'}');
    R('value', or('null','false','true',R('number'),R('string'),R('array'),R('object')));

    json.topRule = 'value';
}
// PEG parser.
{
    let R = peg.rule.bind(peg), and = peg.and.bind(peg), any = peg.any.bind(peg), more = peg.more.bind(peg), or = peg.or.bind(peg);
    let _ = R('space', /[^\S\n]*/);

    let charClasses = {
        Ll: 'a-z',
        Lu: 'A-Z'
    };

    R('identifier', /[a-zA-Z_][a-zA-Z0-9_]*/).filter(($)=>'\''+$.$0+'\'');
    R('regexp', /\[(:\]|[^\]])*\]/).filter(($)=>{
        return '/'+$.$0.replace(/(^\[| )\[:([A-Z][a-z]):\]/g, (str, a, b)=>a+(charClasses[b]||'')).replace(/-U\+/g, '-\\u').replace(/(^\[| )U\+/g, '$1\\u').replace(/\\u00/g, '\\x').replace(/\s+/g, '')+'/';
    });
    R('string', '"',{value:/(?:[^\\"]|\\.)*/},'"').filter(($)=>{
        return '\''+$.value.replace(/([\\'])/g, '\\$1').replace(/\n/g, '\\n')+'\'';
    });
    R('reference', R('identifier')).filter(($)=>'R('+$.$0+')');
    R('primary', or(R('reference'), R('regexp'), R('string'), and('(',/\s*/,R('or'),/\s*/,')').filter(($)=>$.$2))).filter(($)=>$.$0);
    R('unary', or(and(/[!&]/, R('primary')).filter(($)=>{
        if($.$0 == '!') return 'not('+$.$1+')';
        else if($.$0 == '&') return 'is('+$.$1+')';
    }), and(R('primary'), /\{[^}]*\}|[?*+]?/).filter(($)=>{
        if($.$1 == '?') return 'opt('+$.$0+')';
        else if($.$1 == '*') return 'any('+$.$0+')';
        else if($.$1 == '+') return 'more('+$.$0+')';
        else if($.$1[0] == '{') return 'range(['+$.$1.slice(1,-1)+'], '+$.$0+')';
        else return $.$0;
    }))).filter(($)=>$.$0);
    R('and', more(R('unary')).sep(_)).filter(($)=>{
        if($.$0.length == 1) return $.$0[0].$0;
        return 'and('+$.$0.map((x)=>x.$0).join(', ')+')';
    });
    R('or', more(R('and')).sep(/\s*/,'/',_)).filter(($)=>{
        if($.$0.length == 1) return $.$0[0].$0;
        return 'or('+$.$0.map((x)=>x.$0).join(', ')+')';
    });
    R('rule', R('identifier'), /\s*/, '←', /\s*/, R('or'), /\s*/).filter(($)=>{
        if($.$4.slice(0,4) == 'and(')
            $.$4 = $.$4.slice(4,-1);
        return 'R('+$.$0+', '+$.$4+')';
    });
    R('peg', any(or(and(/;[^\n]*\s*/).filter(($)=>$.$0.trim().replace(/^;/,'\n//')), R('rule')))).filter(($)=>$.$0.map((x)=>x.$0).join('\n'));

    peg.topRule = 'peg';
}

$(()=>{
    let output = $ui.Editor({mime: 'text/x-javascript'}).addClass('output').appendTo('body');
    $('.input').change(function() {
        console.time('PEG');
        let result = peg.parse($(this).text());
        console.timeEnd('PEG');
        if(result === false)
            $(this).addClass('error');
        else
            $(this).removeClass('error'), output.text('').append(/*codeaze.prettyPrint(*/result/*)*/).change();
        (function testParser(code) {
            var p = new codeaze.Parser;
            var R = p.rule.bind(p), and = p.and.bind(p), or = p.or.bind(p), range = p.range.bind(p), opt = p.opt.bind(p), any = p.any.bind(p), more = p.more.bind(p), is = p.is.bind(p), not = p.not.bind(p);
            eval(code);
            p.topRule = 'Program';
            console.log(p);
            let parse = window.parse = (x)=>output.append(codeaze.prettyPrint(p.parse(x)));
            parse("var fs = require('fs');");
        })(result);
    }).keyup(function() {
        $(this).change();
    }).change();
});
        </script>
    </head>
    <body>
<div class='input wui-editor' contenteditable>; The entire ECMAScript language as a Parser Expression Grammar

; Parser rules which share a name with ECMA-262 productions are intended to match the same language (though not necessarily with the same derivation).

Program ←
  (S? (Statement / FunctionDeclaration))* S?

FunctionBody ←
  (S? (Statement / FunctionDeclaration))* S?

FunctionDeclaration ←
  FunctionTok S? Identifier S? "(" S? FormalParameterList? S? ")" S? "{" S? FunctionBody S? "}"

FunctionExpression ←
  FunctionTok S? Identifier? S? "(" S? FormalParameterList? S? ")" S? "{" S? FunctionBody S? "}"

FormalParameterList ←
  Identifier ("," S? Identifier)*

UseStrictDirective ←
  "use" S "strict" S ( "," !(LineTerminator) SourceCharacter )*



; Statements

Statement
  ← Block
  / VariableStatement
  / EmptyStatement
  / ExpressionStatement
  / IfStatement
  / IterationStatement
  / ContinueStatement
  / BreakStatement
  / ReturnStatement
  / WithStatement
  / LabelledStatement
  / SwitchStatement
  / ThrowStatement
  / TryStatement
  / DebuggerStatement

Block ← "{" (S? Statement)* S? "}"

VariableStatement ←
  VarTok S? VariableDeclaration (S? "," S? VariableDeclaration)* EOS

VariableDeclaration ←
  Identifier (S? "=" !("=") S? AssignmentExpression)?

VariableDeclarationNoIn ←
  Identifier (S? "=" !("=") S? AssignmentExpressionNoIn)?

VariableDeclarationListNoIn ←
  VariableDeclarationNoIn (S? "," S? VariableDeclarationNoIn)*

; an empty statement is marked by an explicit semicolon, ASI does not apply
EmptyStatement ← ";"

ExpressionStatement ← !("{" / FunctionTok) Expression EOS

IfStatement ← IfTok S? "(" S? Expression S? ")" S? Statement (S? ElseTok S? Statement)?

IterationStatement ←
   DoWhileStatement
 / WhileStatement
 / ForInStatement
 / ForStatement

DoWhileStatement ←
  DoTok S? Statement S? WhileTok S? "(" S? Expression S? ")" EOS

WhileStatement ←
  WhileTok S? "(" S? Expression S? ")" S? Statement

ForInStatement ←
  ForTok S? "(" (ForInLeft/ForInVarLeft) InTok S? Expression S? ")" S? Statement

ForInLeft      ← S? LeftHandSideExpression S?
ForInVarLeft   ← S? VarTok S? VariableDeclarationNoIn S?

ForStatement ←
  ForTok S? "(" S? (ForInit/ForVarInit)? S? ";" S? ForTest? S? ";" S? ForUpdate? S? ")" S? Statement

ForInit      ← ExpressionNoIn
ForVarInit   ← VarTok S? VariableDeclarationListNoIn
ForTest      ← Expression
ForUpdate    ← Expression

ContinueStatement ←
  ContinueTok SnoLB? (Identifier EOS / EOSnoLB)

BreakStatement ←
  BreakTok SnoLB? (Identifier EOS / EOSnoLB)

ReturnStatement ←
  ReturnTok SnoLB? (EOSnoLB / Expression EOS)

WithStatement ←
  WithTok S? "(" S? Expression S? ")" S? Statement

LabelledStatement ←
  Identifier S? ":" S? Statement

SwitchStatement ←
  SwitchTok S? "(" S? Expression S? ")" S? "{" CaseClause* (DefaultClause CaseClause*)? S? "}"

CaseClause ←
  S? CaseTok S? Expression S? ":" (S? Statement)*

DefaultClause ←
  S? DefaultTok S? ":" (S? Statement)*

ThrowStatement ←
  ThrowTok SnoLB? (EOSnoLB / Expression EOS)

TryStatement ←
  TryTok S? Block S? (Catch S? Finally? / Finally)

Catch ←
  CatchTok S? "(" S? Identifier S? ")" S? Block

Finally ←
  FinallyTok S? Block

DebuggerStatement ←
  DebuggerTok S? EOS



; Expressions

Expression ←
  AssignmentExpression (S? "," S? AssignmentExpression)*

ExpressionNoIn ←
  AssignmentExpressionNoIn (S? "," S? AssignmentExpressionNoIn)*

AssignmentExpression ←
   LeftHandSideExpression S? AssignmentOperator S? AssignmentExpression
 / ConditionalExpression

AssignmentExpressionNoIn ←
   LeftHandSideExpression S? AssignmentOperator S? AssignmentExpressionNoIn
 / ConditionalExpressionNoIn

AssignmentOperator ←
  "=" !("=") / "*=" / "/=" / "%=" / "+=" / "-=" / "<<=" / ">>=" / ">>>=" / "&=" / "^=" / "|="

ConditionalExpression ←
  LogicalOrExpression (S? "?" S? AssignmentExpression S? ":" S? AssignmentExpression)?

ConditionalExpressionNoIn ←
  LogicalOrExpressionNoIn (S? "?" S? AssignmentExpressionNoIn S? ":" S? AssignmentExpressionNoIn)?

LogicalOrExpression ←
  LogicalAndExpression (S? "||" S? LogicalAndExpression)*

LogicalOrExpressionNoIn ←
  LogicalAndExpressionNoIn (S? "||" S? LogicalAndExpressionNoIn)*

LogicalAndExpression ←
  BitwiseOrExpression (S? "&&" S? BitwiseOrExpression)*

LogicalAndExpressionNoIn ←
  BitwiseOrExpressionNoIn (S? "&&" S? BitwiseOrExpressionNoIn)*

BitwiseOrExpression ←
  BitwiseXOrExpression (S? "|" !("=") S? BitwiseXOrExpression)*

BitwiseOrExpressionNoIn ←
  BitwiseXOrExpressionNoIn (S? "|" !("=") S? BitwiseXOrExpressionNoIn)*

BitwiseXOrExpression ←
  BitwiseAndExpression (S? "^" !("=") S? BitwiseAndExpression)*

BitwiseXOrExpressionNoIn ←
  BitwiseAndExpressionNoIn (S? "^" !("=") S? BitwiseAndExpressionNoIn)*

BitwiseAndExpression ←
  EqualityExpression (S? "&" !("=") S? EqualityExpression)*

BitwiseAndExpressionNoIn ←
  EqualityExpressionNoIn (S? "&" !("=") S? EqualityExpressionNoIn)*

EqualityExpression ←
  RelationalExpression (S? EqualityOp S? RelationalExpression)*

EqualityExpressionNoIn ←
  RelationalExpressionNoIn (S? EqualityOp S? RelationalExpressionNoIn)*

EqualityOp ← "===" / "!==" / "==" / "!="

RelationalExpression ←
  ShiftExpression (S? RelationalOp S? ShiftExpression)*

RelationalExpressionNoIn ←
  ShiftExpression (S? RelationalOpNoIn S? ShiftExpression)*

RelationalOp ←
  "<=" / ">=" / "<" / ">" / InstanceOfTok / InTok

RelationalOpNoIn ←
  "<=" / ">=" / "<" / ">" / InstanceOfTok

ShiftExpression ←
  AdditiveExpression (S? ShiftOp S? AdditiveExpression)*

ShiftOp ←
  "<<" / ">>>" / ">>"

AdditiveExpression ←
  MultiplicativeExpression (S? AdditiveOp S? MultiplicativeExpression)*

AdditiveOp ←
   "+" !("+"/"=")
 / "-" !("-"/"=")

MultiplicativeExpression ←
  UnaryExpression (S? MultiplicativeOp S? UnaryExpression)*

MultiplicativeOp ←
  ("*" / "/" / "%") !("=")

UnaryExpression ←
   PostfixExpression
 / DeleteExpression
 / VoidExpression
 / TypeofExpression
 / PreIncrementExpression
 / PreDecrementExpression
 / UnaryPlusExpression
 / UnaryMinusExpression
 / BitwiseNotExpression
 / LogicalNotExpression

DeleteExpression        ← DeleteTok S? UnaryExpression
VoidExpression          ← VoidTok S? UnaryExpression
TypeofExpression        ← TypeofTok S? UnaryExpression
PreIncrementExpression  ← "++" S? UnaryExpression
PreDecrementExpression  ← "--" S? UnaryExpression
UnaryPlusExpression     ← "+" S? UnaryExpression
UnaryMinusExpression    ← "-" S? UnaryExpression
BitwiseNotExpression    ← "~" S? UnaryExpression
LogicalNotExpression    ← "!" S? UnaryExpression

; why isn't ++a++ a valid UnaryExpression?
; answer: it is, and parses as ++(a++), the evaluation of which must throw a ReferenceError per spec

PostfixExpression ←
  LeftHandSideExpression (SnoLB? (PostIncrementOp/PostDecrementOp))?

PostIncrementOp ← "++"
PostDecrementOp ← "--"

; This LHSExpression adheres to the spec, which gives semantics for CallExpression and NewExpression
; See ECMAScript_5_streamable.peg for an alternative approach.

LeftHandSideExpression ←
   CallExpression
 / NewExpression

CallExpression ←
  MemberExpression S? Arguments (S? Arguments / S? BracketAccessor / S? DotAccessor)*

BracketAccessor ←
  "[" S? Expression S? "]"

DotAccessor ←
  "." S? IdentifierName

Arguments ←
  "(" S? ArgumentList? S? ")"

ArgumentList ←
  AssignmentExpression (S? "," S? AssignmentExpression)*

NewExpression ←
   MemberExpression
 / NewTok S? NewExpression

MemberExpression ←
  ( PrimaryExpression
  / FunctionExpression
  / NewTok S? MemberExpression S? Arguments
  ) ( S? "[" S? Expression S? "]"
    / S? "." S? IdentifierName
    )*

PrimaryExpression ←
   ThisTok
 / Identifier
 / Literal
 / ArrayLiteral
 / ObjectLiteral
 / "(" S? Expression S? ")"

ArrayLiteral ←
   "[" Elision? S? "]"
 / "[" ElementList S? "]"
 / "[" ElementList S? "," Elision? S? "]"

ElementList ←
  Elision? S? AssignmentExpression (S? "," Elision? S? AssignmentExpression)*

Elision ←
  (S? ",") Elision?

ObjectLiteral ←
  "{" ( S? PropertyNameAndValueList S? ","? )? S? "}"

PropertyNameAndValueList ←
  PropertyAssignment (S? "," S? PropertyAssignment)*

PropertyAssignment ←
   PropertyName S? ":" S? AssignmentExpression
 / PropertyGetter
 / PropertySetter

PropertyGetter ←
  "get" S? PropertyName S? "(" S? ")" S? "{" S? FunctionBody S? "}"

PropertySetter ←
  "set" S? PropertyName S? "(" S? PropertySetParameterList S? ")" S? "{" S? FunctionBody S? "}"

PropertyName ←
  IdentifierName / StringLiteral / NumericLiteral

PropertySetParameterList ←
  Identifier



; Lexical tokens

Literal
  ← NullLiteral
  / BooleanLiteral
  / NumericLiteral
  / StringLiteral
  / RegularExpressionLiteral

NullLiteral
  ← NullTok

BooleanLiteral
  ← TrueTok
  / FalseTok

NumericLiteral                  ← DecimalLiteral !(IdentifierStart)
                                / HexIntegerLiteral !(IdentifierStart)

DecimalLiteral                  ← DecimalIntegerLiteral "." DecimalDigit* ExponentPart?
                                / "." DecimalDigit+ ExponentPart?
                                / DecimalIntegerLiteral ExponentPart?

DecimalIntegerLiteral           ← "0"
                                / [1-9] DecimalDigit*

DecimalDigit                    ← [0-9]

ExponentPart                    ← [eE] SignedInteger

SignedInteger                   ← DecimalDigit+
                                / "+" DecimalDigit+
                                / "-" DecimalDigit+

HexIntegerLiteral               ← "0x" HexDigit+
                                / "0X" HexDigit+

DQ                              ← [U+0022]
SQ                              ← [U+0027]

StringLiteral                   ← DQ DoubleStringCharacter* DQ
                                / SQ SingleStringCharacter* SQ

RS                              ← [U+005C]

DoubleStringCharacter           ← !( DQ / RS / LineTerminator ) SourceCharacter
                                / RS EscapeSequence
                                / LineContinuation

SingleStringCharacter           ← !( SQ / RS / LineTerminator ) SourceCharacter
                                / RS EscapeSequence
                                / LineContinuation

LineContinuation                ← RS LineTerminatorSequence

EscapeSequence                  ← CharacterEscapeSequence
                                / "0" !(DecimalDigit)
                                / HexEscapeSequence
                                / UnicodeEscapeSequence

CharacterEscapeSequence         ← SingleEscapeCharacter
                                / NonEscapeCharacter

SingleEscapeCharacter           ← [ U+0027 U+0022 U+005C b f n r t v ]

NonEscapeCharacter              ← !(EscapeCharacter / LineTerminator) SourceCharacter

EscapeCharacter                 ← SingleEscapeCharacter
                                / DecimalDigit
                                / [ x u ]

HexEscapeSequence               ← "x" HexDigit HexDigit

UnicodeEscapeSequence           ← "u" HexDigit{4}

RegularExpressionLiteral        ← "/" RegularExpressionBody "/" RegularExpressionFlags

RegularExpressionBody           ← RegularExpressionFirstChar RegularExpressionChar*

RegularExpressionFirstChar      ← !( LineTerminator / [ * U+005C / [ ] ) SourceCharacter
                                / RegularExpressionBackslashSequence
                                / RegularExpressionClass

RegularExpressionChar           ← !( LineTerminator / [ U+005C / [ ] ) SourceCharacter
                                / RegularExpressionBackslashSequence
                                / RegularExpressionClass

RegularExpressionBackslashSequence ← RS !(LineTerminator) SourceCharacter

RegularExpressionClass          ← "[" RegularExpressionClassChar* "]"

RegularExpressionClassChar      ← !(LineTerminator / [ U+005C U+005D ]) SourceCharacter
                                / RegularExpressionBackslashSequence

RegularExpressionFlags          ← IdentifierPart*

SourceCharacter                 ← [ U+0000-U+10FFFF ]

WhiteSpace                      ← [ U+0009
                                    U+000B
                                    U+000C
                                    U+0020
                                    U+0085
                                    U+00A0
                                    U+200B
                                    U+FEFF
                                    [:Zs:] ]

LF                              ← [ U+000A ]
CR                              ← [ U+000D ]
LS                              ← [ U+2028 ]
PS                              ← [ U+2029 ]

LineTerminator                  ← LF / CR / LS / PS

LineTerminatorSequence          ← LF / CR LF / CR / LS / PS

Comment                         ← MultiLineComment
                                / SingleLineComment

MultiLineComment                ← "/*" (!("*/") SourceCharacter)* "*/"

MultiLineCommentNoLB            ← "/*" (!("*/") !(LineTerminator) SourceCharacter)* "*/"

SingleLineComment               ← "//" [^ U+000A U+000D U+2028 U+2029 ]*

S ← ( WhiteSpace / LineTerminatorSequence / Comment )+

SnoLB ← ( WhiteSpace / SingleLineComment / MultiLineCommentNoLB )+

; end of statement
EOS
 ← S? ";"
 / SnoLB? LineTerminatorSequence
 / SnoLB? &("}")
 / S? EOF

; end of statement in a "no linebreak here" context
; EOSnoLB will consume a linebreak, but it won't extend to the next line
EOSnoLB
 ← SnoLB? ";"
 / SnoLB? LineTerminatorSequence
 / SnoLB? &("}")
 / SnoLB? EOF

EOF
 ← !(SourceCharacter)

ReservedWord
 ← ( Keyword
   / FutureReservedWord
   / "null"
   / "true"
   / "false"
   ) !(IdentifierPart)

Keyword
 ← "break" / "case" / "catch" / "continue" / "debugger" / "default" / "delete" / "do" / "else" / "finally" / "for" / "function" / "if" / "instanceof" / "in" / "new" / "return" / "switch" / "this" / "throw" / "try" / "typeof" / "var" / "void" / "while" / "with"

FutureReservedWord
 ← "abstract" / "boolean" / "byte" / "char" / "class" / "const" / "double" / "enum" / "export" / "extends" / "final" / "float" / "goto" / "implements" / "import" / "interface" / "int" / "long" / "native" / "package" / "private" / "protected" / "public" / "short" / "static" / "super" / "synchronized" / "throws" / "transient" / "volatile"

Identifier                      ← !(ReservedWord) IdentifierName

IdentifierName                  ← IdentifierStart IdentifierPart*

IdentifierStart                 ← UnicodeLetter
                                / "$"
                                / "_"
                                / RS UnicodeEscapeSequence

IdentifierPart                  ← IdentifierStart
                                / [ [:Mn:] [:Mc:]
                                    [:Nd:]
                                    [:Pc:] ]

UnicodeLetter                   ← [ [:Lu:]
                                    [:Ll:]
                                    [:Lt:]
                                    [:Lm:]
                                    [:Lo:]
                                    [:Nl:] ]

HexDigit                        ← [ 0-9 a-f A-F ]

FalseTok      ← "false"      !(IdentifierPart)
TrueTok       ← "true"       !(IdentifierPart)
NullTok       ← "null"       !(IdentifierPart)
BreakTok      ← "break"      !(IdentifierPart)
ContinueTok   ← "continue"   !(IdentifierPart)
DebuggerTok   ← "debugger"   !(IdentifierPart)
InTok         ← "in"         !(IdentifierPart)
InstanceOfTok ← "instanceof" !(IdentifierPart)
DeleteTok     ← "delete"     !(IdentifierPart)
FunctionTok   ← "function"   !(IdentifierPart)
NewTok        ← "new"        !(IdentifierPart)
ThisTok       ← "this"       !(IdentifierPart)
TypeofTok     ← "typeof"     !(IdentifierPart)
VoidTok       ← "void"       !(IdentifierPart)
IfTok         ← "if"         !(IdentifierPart)
ElseTok       ← "else"       !(IdentifierPart)
DoTok         ← "do"         !(IdentifierPart)
WhileTok      ← "while"      !(IdentifierPart)
ForTok        ← "for"        !(IdentifierPart)
VarTok        ← "var"        !(IdentifierPart)
ReturnTok     ← "return"     !(IdentifierPart)
CaseTok       ← "case"       !(IdentifierPart)
DefaultTok    ← "default"    !(IdentifierPart)
SwitchTok     ← "switch"     !(IdentifierPart)
ThrowTok      ← "throw"      !(IdentifierPart)
CatchTok      ← "catch"      !(IdentifierPart)
FinallyTok    ← "finally"    !(IdentifierPart)
TryTok        ← "try"        !(IdentifierPart)
WithTok       ← "with"       !(IdentifierPart)
</div>
    </body>
</html>
